리팩터링
=============

리팩터링의 목적이 무엇일까? 코드의 가독성을 높이기? 아니면 유지보수성을 높이기?
조기/애자일 품질을 보증하기 위해 리팩터링이 필요하다!
- 코드에 관한 본질론에서 리팩터링을 권장
- 익스트림 프로그래밍의 실천 방안으로서의 리팩터링 = 정확히는 코드구조를 바꾸는게 아니라 코드 작성의 흐름을 정비하기 위함임

+) 익스트림 프로그래밍 = 소프트웨어 개발 프로세스 중 하나로, 빠르고 반응성 높은 개발 사이클을 강조하는 애자일 개발 방법론(짧은 릴리즈 사이클과 페어 프로그래밍등이 특징)

이번에는 **코드 품질의 본질론**에서 리팩터링에 관해 생각해보자!

## 7.1 단위 테스트가 어려운 복잡한 코드

코드가 일정 수준 이상 복잡할때 단위테스트를 작성하기보단 다음의 리팩터링을 시도해보자!

1. 파일의 전체복잡도가 높다면 먼저 파일을 2~3개로 분리한다.
2. 그래도 복잡도가 내려가지 않는다면 기존의 복잡한 함수 코드에 대한 단위 테스트를 작성한다.
3. 목(mock)을 작성한다.
4. 커버리지 비율을 측정하고 커버리지 비율이 75%가 될 때 까지 단위 테스트를 추가한다.
5. 리팩터링한다.
6. 단위테스트를 실행하고 결과가 같은지를 확인한다.

Q) 그런데 해당 서비스코드를 참조하고있는 다른 메서드들이 많다면 이렇게 함부러 리팩토링해도되는건가?(로직을 분리해도..?)

이와 같은 사항에 주목
- 복잡도 낮추기
- 출구를 하나로 통합
- MVC를 분리
- 파일 코드의 단축

## 7.2 파일 코드 리팩터링

사실 파일의 코드가 길어지는 이유는 책임과 의무가 적절하게 구분되지 않았기 때문! (클린코드하셔라~)

안티패턴
- 어떤 파일에도 포함되기 애매하니 어딘가에 대충 넣어두는 경우
- 매우 많은 중복 코드
- 규모가 큰 클래스에 의한 파일의 비대화

PS) C언어에서 함수를 사용하면 프로그램의 실행 속도가 느려지므로 중복코드가 정당화되었던경우도 있으나 이제는 멀티코어 환경이 당연한 시대다보니 이건 핑계임!

## 7.3 큰 클래스의 리팩터링

큰 클래스의 리팩터링 또한 파일 코드를 짧게 만드는 리팩터링 방법임!

### CK 지표
ck 지표는 하나의 지표가 아닌 몇가지 지표의 집합임 -> 간단히 말하면 클래스 구조가 복잡하다거나 1개의 클래스에 지나치게 많은 멤버를 넣으면 버그가 발생한다와 같은 지표

WMC = 클래스당 평균 메서드수 -> 평균 WMC는 프로그램의 모든 메서드를 세고, 그것을 모든 클래스 수로 나누면 됨

결론만 말하자면 클래스당 메서드 수는 10개를 안넘는게 좋음

CK 지표 그룹에는 WMC외에도 DIT(평균 클래스 상속 깊이)또는 NOC(평균 자식 클래스 수)등이 있음
CK 지표의 값이 클때에는 반드시 리팩터링! 마틴 파울러가 제안한 클래스 추출이라는 방법 활용해볼것!

### 큰 클래스를 쪼개는 방식

![alt text](image.png)

(출처 : http://dj6316.torchpad.com/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%28refactoring%29/CH.07+%EA%B0%9D%EC%B2%B4++%EA%B0%84%EC%9D%98+%EA%B8%B0%EB%8A%A5++%EC%9D%B4%EB%8F%99/18.%ED%81%B4%EB%9E%98%EC%8A%A4+%EC%B6%94%EC%B6%9C+Extract+Class)

클래스를 분리했을때의 장점? 단위 테스트를 더 쉽게 작성할 수 있음, 핫스팟 값도 줄어듬!(잘 진행하면 핫스팟 기반의 단위테스트 대상 파일의 갯수 자체가 줄어들기도)


## 7.4 복잡도를 낮추는 리팩터링

복잡도란? 프로그램의 제어 흐름을 유효 그래프로 표현하고 그 그래프가 가진 특성에 기반해 프로그램의 복잡성을 나타내는 방법

- 높은 복잡도 = 버그가 발생하는 좋지 않은 함수

복잡도가 높은 부분을 수정하면 실패할 확률이 높으므로 프로젝트 후반 단계에서의 버그 수정은 하지 않는게 좋음.. 다만 초반 또는 중간 단계에서의 버그 수정은 적극적으로해야함.

## 7.5 출구는 하나

가장 중요한 코딩 표준 = 함수의 출구를 한군데 또는 두군데로 만드는 것. 출구가 두군데일 경우 반드시 입구에서 파라미터에 대한 에러 체크만하며 절대로 함수안에서 return하지 않아야함

무슨얘기일까? 함수의 출구를 한군데 또는 두군데로 만든다는 말은, 함수 내에서 데이터의 흐름을 단순화시켜, 함수가 반환(return)을 수행하는 위치를 제한하는 코딩 원칙을 의미함

**단일 출구 원칙** : 함수는 단 한군데서만 종료 되어야함, 함수의 흐름을 추적하기 쉽고 함수 종료 시 필요한 정리 작업이나 추가적인 처리를 한곳에서만 관리할 수 있게 해줌. 

예를 들어 함수 마지막 부분에서만 결과값을 반환하고 그 이전의 모든 조건분기는 결과값을 변수에 저장만하고 실제 반환은 함수의 맨 마지막에서 실행!

**이중 출구 원칙** : 일부 경우에는 함수 시작 부분에서 입력 파라미터에 대한 검증이나 에러 체크를 수행하고 잘못된 입력에 대해 즉시 반환하는 것이 효과적. 이런 경우엔 함수에 두군데의 출구가 있게됨. 하나는 입력 검증 후 초기 에러 처리용 다른 하나는 정상적인 종료 지점

예를 들어 이런거임

```
public int divide(int numerator, int denominator) {
    if (denominator == 0) {
        return -1; // Early exit on error condition
    }

    int result = numerator / denominator;
    return result; // Normal exit point
}

```

여기선 입력값에 대한 오류가 있다면 해당 오류에 대한 출구 하나. 정상적인 상황에서의 출구 하나만 있음 = 이중 출구

여기에 대한 필자의 조언은 단순한 계산이나 데이터베이스의 저장을 함수의 최하층에서 수행하고 저장이나 반환값만 체크하는 단위 테스트가 유지보수하기 쉽다고함

## 7.6 MVC 분리

모델-뷰-컨트롤러
MVC 아키텍처를 보증해야함! (뭐 대충 중요한 이유는 많이 적어놓긴했는데 생략)

간단히 설명하자면
**Model**      : 백그라운드에서 동작하며, 사용자가 원하는 데이터나 정보를 제공한다.

**View**        : 사용자의 요청을 화면으로 출력한다.

**Controller** : 사용자의 요청을 처리하고, 그 요청에 따른 전체적인 흐름을 제어한다.

여기서 중요한건 View에는 자바스크립트등 계산 프로그램을 포함하지 말것. 

왜 뷰를 분리해야할까? 뷰 테스트는 단위 테스트화가 어렵고 비용이 드는 시스템 테스트가 됨. 뷰 테스트에는 시간도 걸리고 UI 변경은 얼마든지 발생하기 때문